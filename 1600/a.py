import math

waynoints = [[-6.85582051,  0.87480923],
             [-6.91157606,  0.6086127],
             [-6.95133921,  0.33772747],
             [-6.97558139,  0.06392022],
             [-6.98482361, -0.21123515],
             [-6.97961723, -0.48637133],
             [-6.96054077, -0.76032286],
             [-6.92814444, -1.032088],
             [-6.8825754, -1.30070642],
             [-6.8235897, -1.56516697],
             [-6.74990452, -1.82400426],
             [-6.65999976, -2.07536957],
             [-6.55163544, -2.31666425],
             [-6.42152898, -2.54394589],
             [-6.26602686, -2.75164807],
             [-6.07877295, -2.92771953],
             [-5.86995045, -3.07540621],
             [-5.64546621, -3.19753242],
             [-5.40971017, -3.29748026],
             [-5.16529263, -3.37719315],
             [-4.91431617, -3.43879508],
             [-4.65817789, -3.48358912],
             [-4.39783598, -3.5120337],
             [-4.13296037, -3.51588877],
             [-3.86586622, -3.49945727],
             [-3.59775042, -3.46607165],
             [-3.3292971, -3.41830137],
             [-3.06091283, -3.35826316],
             [-2.79283773, -3.28773722],
             [-2.52520704, -3.2082503],
             [-2.25808696, -3.12113945],
             [-1.99149637, -3.02759025],
             [-1.7254062, -2.92879483],
             [-1.45978337, -2.82561434],
             [-1.19457885, -2.71883723],
             [-0.92973132, -2.60919302],
             [-0.66517225, -2.49735056],
             [-0.40083191, -2.38390571],
             [-0.13663501, -2.26943843],
             [0.12748956, -2.15446315],
             [0.38601951, -2.04223164],
             [0.64444166, -1.93040844],
             [0.90268263, -1.81925929],
             [1.16067631, -1.70900962],
             [1.41835886, -1.59985943],
             [1.67566201, -1.49200227],
             [1.93253009, -1.38556664],
             [2.18891774, -1.28063048],
             [2.44479784, -1.17720542],
             [2.70016997, -1.07522344],
             [2.95504297, -0.9745948],
             [3.20943718, -0.87520487],
             [3.4633644, -0.77696587],
             [3.71683481, -0.67979824],
             [3.96978665, -0.58378021],
             [4.22210597, -0.48906155],
             [4.46402873, -0.39938262],
             [4.70487863, -0.3074864],
             [4.94340047, -0.21083697],
             [5.17818042, -0.10683711],
             [5.40744876,  0.00710227],
             [5.62865216,  0.13377447],
             [5.83830357,  0.27594179],
             [6.03151461,  0.43634924],
             [6.20055463,  0.61756004],
             [6.34750761,  0.8134188],
             [6.47297676,  1.02077769],
             [6.57766117,  1.23713296],
             [6.66203607,  1.46049852],
             [6.72641477,  1.6891591],
             [6.77053225,  1.92157358],
             [6.79365517,  2.15617524],
             [6.79341047,  2.39115489],
             [6.76720406,  2.62397086],
             [6.71101837,  2.85088108],
             [6.62039123,  3.06636344],
             [6.48829928,  3.26082101],
             [6.30816757,  3.41781697],
             [6.09672848,  3.53976124],
             [5.86301646,  3.62958365],
             [5.61352861,  3.69054678],
             [5.35305174,  3.72500303],
             [5.08577088,  3.7359859],
             [4.81481503,  3.72618294],
             [4.54245881,  3.69797202],
             [4.27030444,  3.65346061],
             [3.99943783,  3.59452926],
             [3.73049361,  3.52315895],
             [3.46390086,  3.44056378],
             [3.19989887,  3.34789003],
             [2.93861973,  3.2460849],
             [2.68011553,  3.13596193],
             [2.42439039,  3.01821952],
             [2.17139221,  2.89353337],
             [1.92113454,  2.76229359],
             [1.67376363,  2.62452722],
             [1.42988203,  2.47931161],
             [1.19048281,  2.325167],
             [0.9543544,  2.16487733],
             [0.7209096,  1.99973246],
             [0.48973621,  1.8306353],
             [0.26053643,  1.65828008],
             [0.03308459,  1.48325438],
             [-0.19271361,  1.30598119],
             [-0.41692115,  1.12688858],
             [-0.63959875,  0.94640242],
             [-0.86050139,  0.76974149],
             [-1.08297242,  0.59839145],
             [-1.30781627,  0.4357336],
             [-1.53567213,  0.28575046],
             [-1.76666334,  0.15241958],
             [-2.00029332,  0.04012539],
             [-2.23519078, -0.04633832],
             [-2.46882215, -0.10180552],
             [-2.69680858, -0.11968226],
             [-2.91258094, -0.09467801],
             [-3.1067693, -0.02209077],
             [-3.26608671,  0.10134642],
             [-3.39816558,  0.25495049],
             [-3.50413067,  0.43350137],
             [-3.58475196,  0.63327128],
             [-3.64119856,  0.85080151],
             [-3.67505857,  1.08282992],
             [-3.68747497,  1.32674953],
             [-3.68018488,  1.56762407],
             [-3.69124762,  1.80068168],
             [-3.72592882,  2.02280717],
             [-3.78957952,  2.23001654],
             [-3.88698778,  2.41733123],
             [-4.03272152,  2.56819405],
             [-4.21360697,  2.68154508],
             [-4.41886471,  2.75664627],
             [-4.63868465,  2.79513592],
             [-4.86566751,  2.79864823],
             [-5.09406285,  2.77038166],
             [-5.31979083,  2.71318019],
             [-5.54003488,  2.63019013],
             [-5.75240222,  2.522895],
             [-5.95453675,  2.39209655],
             [-6.14376907,  2.2379346],
             [-6.31202799,  2.05462056],
             [-6.45898051,  1.8482035],
             [-6.58604104,  1.62385373],
             [-6.6939532,  1.38492351],
             [-6.78352602,  1.13433505],
             [-6.85582051,  0.87480923]]


def dist(point1, point2):
    return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5


def rect(r, theta):

    x = r * math.cos(math.radians(theta))
    y = r * math.sin(math.radians(theta))
    return x, y


def polar(x, y):

    r = (x ** 2 + y ** 2) ** .5
    theta = math.degrees(math.atan2(y, x))
    return r, theta


def angle_mod_360(angle):

    n = math.floor(angle/360.0)

    angle_between_0_and_360 = angle - n*360.0

    if angle_between_0_and_360 <= 180.0:
        return angle_between_0_and_360
    else:
        return angle_between_0_and_360 - 360


def get_waypoints_ordered_in_driving_direction(params):
    # waypoints are always provided in counter clock wise order
    if params['is_reversed']:  # driving clock wise.
        return list(reversed(waynoints))
    else:  # driving counter clock wise.
        return waynoints


def up_sample(waypoints, factor):

    p = waypoints
    n = len(p)

    return [[i / factor * p[(j+1) % n][0] + (1 - i / factor) * p[j][0],
             i / factor * p[(j+1) % n][1] + (1 - i / factor) * p[j][1]] for j in range(n) for i in range(factor)]


def get_target_point(params):
    waypoints = up_sample(
        get_waypoints_ordered_in_driving_direction(params), 20)

    car = [params['x'], params['y']]

    distances = [dist(p, car) for p in waypoints]
    min_dist = min(distances)
    i_closest = distances.index(min_dist)

    n = len(waypoints)

    waypoints_starting_with_closest = [
        waypoints[(i+i_closest) % n] for i in range(n)]

    r = params['track_width'] * 0.9

    is_inside = [dist(p, car) < r for p in waypoints_starting_with_closest]
    i_first_outside = is_inside.index(False)

    if i_first_outside < 0:  # this can only happen if we choose r as big as the entire track
        return waypoints[i_closest]

    return waypoints_starting_with_closest[i_first_outside]


def get_target_steering_degree(params):
    tx, ty = get_target_point(params)
    car_x = params['x']
    car_y = params['y']
    dx = tx-car_x
    dy = ty-car_y
    heading = params['heading']

    _, target_angle = polar(dx, dy)

    steering_angle = target_angle - heading

    return angle_mod_360(steering_angle)


def score_steer_to_point_ahead(params):
    best_stearing_angle = get_target_steering_degree(params)
    steering_angle = params['steering_angle']

    error = (steering_angle - best_stearing_angle)/(10.0)

    score = 1.0 - abs(error)

    # optimizer is rumored to struggle with negative numbers and numbers too close to zero
    return max(score, 0.01)


def reward_function(params):
    return float(score_steer_to_point_ahead(params)*params['speed']*10)


